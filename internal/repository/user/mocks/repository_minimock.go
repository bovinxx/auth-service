// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/bovinxx/auth-service/internal/repository/user.Repository -o repository_minimock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/bovinxx/auth-service/internal/models"
	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_user.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user *models.User) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user *models.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mRepositoryMockCreateUser

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mRepositoryMockDeleteUser

	funcGetUserByID          func(ctx context.Context, id int64) (up1 *models.User, err error)
	funcGetUserByIDOrigin    string
	inspectFuncGetUserByID   func(ctx context.Context, id int64)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mRepositoryMockGetUserByID

	funcGetUserByUsername          func(ctx context.Context, username string) (up1 *models.User, err error)
	funcGetUserByUsernameOrigin    string
	inspectFuncGetUserByUsername   func(ctx context.Context, username string)
	afterGetUserByUsernameCounter  uint64
	beforeGetUserByUsernameCounter uint64
	GetUserByUsernameMock          mRepositoryMockGetUserByUsername

	funcUpdateUser          func(ctx context.Context, id int64, oldPassword string, newPassword string) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, id int64, oldPassword string, newPassword string)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mRepositoryMockUpdateUser
}

// NewRepositoryMock returns a mock for mm_user.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*RepositoryMockCreateUserParams{}

	m.DeleteUserMock = mRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*RepositoryMockDeleteUserParams{}

	m.GetUserByIDMock = mRepositoryMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*RepositoryMockGetUserByIDParams{}

	m.GetUserByUsernameMock = mRepositoryMockGetUserByUsername{mock: m}
	m.GetUserByUsernameMock.callArgs = []*RepositoryMockGetUserByUsernameParams{}

	m.UpdateUserMock = mRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*RepositoryMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCreateUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserExpectation
	expectations       []*RepositoryMockCreateUserExpectation

	callArgs []*RepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateUserExpectation specifies expectation struct of the Repository.CreateUser
type RepositoryMockCreateUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateUserParams
	paramPtrs          *RepositoryMockCreateUserParamPtrs
	expectationOrigins RepositoryMockCreateUserExpectationOrigins
	results            *RepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateUserParams contains parameters of the Repository.CreateUser
type RepositoryMockCreateUserParams struct {
	ctx  context.Context
	user *models.User
}

// RepositoryMockCreateUserParamPtrs contains pointers to parameters of the Repository.CreateUser
type RepositoryMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// RepositoryMockCreateUserResults contains results of the Repository.CreateUser
type RepositoryMockCreateUserResults struct {
	i1  int64
	err error
}

// RepositoryMockCreateUserOrigins contains origins of expectations of the Repository.CreateUser
type RepositoryMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mRepositoryMockCreateUser) Optional() *mRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Expect(ctx context.Context, user *models.User) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &RepositoryMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &RepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) ExpectUserParam2(user *models.User) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &RepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Inspect(f func(ctx context.Context, user *models.User)) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Return(i1 int64, err error) *RepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &RepositoryMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the Repository.CreateUser method
func (mmCreateUser *mRepositoryMockCreateUser) Set(f func(ctx context.Context, user *models.User) (i1 int64, err error)) *RepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the Repository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mRepositoryMockCreateUser) When(ctx context.Context, user *models.User) *RepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &RepositoryMockCreateUserParams{ctx, user},
		expectationOrigins: RepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.CreateUser should be invoked
func (mmCreateUser *mRepositoryMockCreateUser) Times(n uint64) *mRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of RepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_user.Repository
func (mmCreateUser *RepositoryMock) CreateUser(ctx context.Context, user *models.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := RepositoryMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the RepositoryMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to RepositoryMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mRepositoryMockCreateUser) Calls() []*RepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mRepositoryMockDeleteUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteUserExpectation
	expectations       []*RepositoryMockDeleteUserExpectation

	callArgs []*RepositoryMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteUserExpectation specifies expectation struct of the Repository.DeleteUser
type RepositoryMockDeleteUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteUserParams
	paramPtrs          *RepositoryMockDeleteUserParamPtrs
	expectationOrigins RepositoryMockDeleteUserExpectationOrigins
	results            *RepositoryMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteUserParams contains parameters of the Repository.DeleteUser
type RepositoryMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// RepositoryMockDeleteUserParamPtrs contains pointers to parameters of the Repository.DeleteUser
type RepositoryMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// RepositoryMockDeleteUserResults contains results of the Repository.DeleteUser
type RepositoryMockDeleteUserResults struct {
	err error
}

// RepositoryMockDeleteUserOrigins contains origins of expectations of the Repository.DeleteUser
type RepositoryMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mRepositoryMockDeleteUser) Optional() *mRepositoryMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Expect(ctx context.Context, id int64) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &RepositoryMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &RepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) ExpectIdParam2(id int64) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &RepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Return(err error) *RepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &RepositoryMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the Repository.DeleteUser method
func (mmDeleteUser *mRepositoryMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *RepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the Repository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mRepositoryMockDeleteUser) When(ctx context.Context, id int64) *RepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &RepositoryMockDeleteUserParams{ctx, id},
		expectationOrigins: RepositoryMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteUser should be invoked
func (mmDeleteUser *mRepositoryMockDeleteUser) Times(n uint64) *mRepositoryMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of RepositoryMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mRepositoryMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_user.Repository
func (mmDeleteUser *RepositoryMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := RepositoryMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("RepositoryMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("RepositoryMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("RepositoryMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the RepositoryMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to RepositoryMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished RepositoryMock.DeleteUser invocations
func (mmDeleteUser *RepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of RepositoryMock.DeleteUser invocations
func (mmDeleteUser *RepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mRepositoryMockDeleteUser) Calls() []*RepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mRepositoryMockGetUserByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserByIDExpectation
	expectations       []*RepositoryMockGetUserByIDExpectation

	callArgs []*RepositoryMockGetUserByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetUserByIDExpectation specifies expectation struct of the Repository.GetUserByID
type RepositoryMockGetUserByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetUserByIDParams
	paramPtrs          *RepositoryMockGetUserByIDParamPtrs
	expectationOrigins RepositoryMockGetUserByIDExpectationOrigins
	results            *RepositoryMockGetUserByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetUserByIDParams contains parameters of the Repository.GetUserByID
type RepositoryMockGetUserByIDParams struct {
	ctx context.Context
	id  int64
}

// RepositoryMockGetUserByIDParamPtrs contains pointers to parameters of the Repository.GetUserByID
type RepositoryMockGetUserByIDParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// RepositoryMockGetUserByIDResults contains results of the Repository.GetUserByID
type RepositoryMockGetUserByIDResults struct {
	up1 *models.User
	err error
}

// RepositoryMockGetUserByIDOrigins contains origins of expectations of the Repository.GetUserByID
type RepositoryMockGetUserByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByID *mRepositoryMockGetUserByID) Optional() *mRepositoryMockGetUserByID {
	mmGetUserByID.optional = true
	return mmGetUserByID
}

// Expect sets up expected params for Repository.GetUserByID
func (mmGetUserByID *mRepositoryMockGetUserByID) Expect(ctx context.Context, id int64) *mRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("RepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &RepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.paramPtrs != nil {
		mmGetUserByID.mock.t.Fatalf("RepositoryMock.GetUserByID mock is already set by ExpectParams functions")
	}

	mmGetUserByID.defaultExpectation.params = &RepositoryMockGetUserByIDParams{ctx, id}
	mmGetUserByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetUserByID
func (mmGetUserByID *mRepositoryMockGetUserByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("RepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &RepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("RepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &RepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByID
}

// ExpectIdParam2 sets up expected param id for Repository.GetUserByID
func (mmGetUserByID *mRepositoryMockGetUserByID) ExpectIdParam2(id int64) *mRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("RepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &RepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("RepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &RepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.id = &id
	mmGetUserByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUserByID
func (mmGetUserByID *mRepositoryMockGetUserByID) Inspect(f func(ctx context.Context, id int64)) *mRepositoryMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by Repository.GetUserByID
func (mmGetUserByID *mRepositoryMockGetUserByID) Return(up1 *models.User, err error) *RepositoryMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("RepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &RepositoryMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &RepositoryMockGetUserByIDResults{up1, err}
	mmGetUserByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// Set uses given function f to mock the Repository.GetUserByID method
func (mmGetUserByID *mRepositoryMockGetUserByID) Set(f func(ctx context.Context, id int64) (up1 *models.User, err error)) *RepositoryMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	mmGetUserByID.mock.funcGetUserByIDOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// When sets expectation for the Repository.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mRepositoryMockGetUserByID) When(ctx context.Context, id int64) *RepositoryMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("RepositoryMock.GetUserByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserByIDExpectation{
		mock:               mmGetUserByID.mock,
		params:             &RepositoryMockGetUserByIDParams{ctx, id},
		expectationOrigins: RepositoryMockGetUserByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUserByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserByIDExpectation) Then(up1 *models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserByIDResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.GetUserByID should be invoked
func (mmGetUserByID *mRepositoryMockGetUserByID) Times(n uint64) *mRepositoryMockGetUserByID {
	if n == 0 {
		mmGetUserByID.mock.t.Fatalf("Times of RepositoryMock.GetUserByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByID.expectedInvocations, n)
	mmGetUserByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByID
}

func (mmGetUserByID *mRepositoryMockGetUserByID) invocationsDone() bool {
	if len(mmGetUserByID.expectations) == 0 && mmGetUserByID.defaultExpectation == nil && mmGetUserByID.mock.funcGetUserByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByID.mock.afterGetUserByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByID implements mm_user.Repository
func (mmGetUserByID *RepositoryMock) GetUserByID(ctx context.Context, id int64) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	mmGetUserByID.t.Helper()

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(ctx, id)
	}

	mm_params := RepositoryMockGetUserByIDParams{ctx, id}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, &mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByID.GetUserByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetUserByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByID.t.Errorf("RepositoryMock.GetUserByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUserByID.t.Errorf("RepositoryMock.GetUserByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("RepositoryMock.GetUserByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the RepositoryMock.GetUserByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(ctx, id)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to RepositoryMock.GetUserByID. %v %v", ctx, id)
	return
}

// GetUserByIDAfterCounter returns a count of finished RepositoryMock.GetUserByID invocations
func (mmGetUserByID *RepositoryMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of RepositoryMock.GetUserByID invocations
func (mmGetUserByID *RepositoryMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mRepositoryMockGetUserByID) Calls() []*RepositoryMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserByIDDone() bool {
	if m.GetUserByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByIDMock.invocationsDone()
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByIDCounter := mm_atomic.LoadUint64(&m.afterGetUserByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && afterGetUserByIDCounter < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByID at\n%s", m.GetUserByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByID at\n%s with params: %#v", m.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && afterGetUserByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetUserByID at\n%s", m.funcGetUserByIDOrigin)
	}

	if !m.GetUserByIDMock.invocationsDone() && afterGetUserByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetUserByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByIDMock.expectedInvocations), m.GetUserByIDMock.expectedInvocationsOrigin, afterGetUserByIDCounter)
	}
}

type mRepositoryMockGetUserByUsername struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserByUsernameExpectation
	expectations       []*RepositoryMockGetUserByUsernameExpectation

	callArgs []*RepositoryMockGetUserByUsernameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetUserByUsernameExpectation specifies expectation struct of the Repository.GetUserByUsername
type RepositoryMockGetUserByUsernameExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetUserByUsernameParams
	paramPtrs          *RepositoryMockGetUserByUsernameParamPtrs
	expectationOrigins RepositoryMockGetUserByUsernameExpectationOrigins
	results            *RepositoryMockGetUserByUsernameResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetUserByUsernameParams contains parameters of the Repository.GetUserByUsername
type RepositoryMockGetUserByUsernameParams struct {
	ctx      context.Context
	username string
}

// RepositoryMockGetUserByUsernameParamPtrs contains pointers to parameters of the Repository.GetUserByUsername
type RepositoryMockGetUserByUsernameParamPtrs struct {
	ctx      *context.Context
	username *string
}

// RepositoryMockGetUserByUsernameResults contains results of the Repository.GetUserByUsername
type RepositoryMockGetUserByUsernameResults struct {
	up1 *models.User
	err error
}

// RepositoryMockGetUserByUsernameOrigins contains origins of expectations of the Repository.GetUserByUsername
type RepositoryMockGetUserByUsernameExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) Optional() *mRepositoryMockGetUserByUsername {
	mmGetUserByUsername.optional = true
	return mmGetUserByUsername
}

// Expect sets up expected params for Repository.GetUserByUsername
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) Expect(ctx context.Context, username string) *mRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("RepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &RepositoryMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs != nil {
		mmGetUserByUsername.mock.t.Fatalf("RepositoryMock.GetUserByUsername mock is already set by ExpectParams functions")
	}

	mmGetUserByUsername.defaultExpectation.params = &RepositoryMockGetUserByUsernameParams{ctx, username}
	mmGetUserByUsername.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByUsername.expectations {
		if minimock.Equal(e.params, mmGetUserByUsername.defaultExpectation.params) {
			mmGetUserByUsername.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByUsername.defaultExpectation.params)
		}
	}

	return mmGetUserByUsername
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetUserByUsername
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("RepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &RepositoryMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.params != nil {
		mmGetUserByUsername.mock.t.Fatalf("RepositoryMock.GetUserByUsername mock is already set by Expect")
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs == nil {
		mmGetUserByUsername.defaultExpectation.paramPtrs = &RepositoryMockGetUserByUsernameParamPtrs{}
	}
	mmGetUserByUsername.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByUsername.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByUsername
}

// ExpectUsernameParam2 sets up expected param username for Repository.GetUserByUsername
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) ExpectUsernameParam2(username string) *mRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("RepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &RepositoryMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.params != nil {
		mmGetUserByUsername.mock.t.Fatalf("RepositoryMock.GetUserByUsername mock is already set by Expect")
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs == nil {
		mmGetUserByUsername.defaultExpectation.paramPtrs = &RepositoryMockGetUserByUsernameParamPtrs{}
	}
	mmGetUserByUsername.defaultExpectation.paramPtrs.username = &username
	mmGetUserByUsername.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserByUsername
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUserByUsername
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) Inspect(f func(ctx context.Context, username string)) *mRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.inspectFuncGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUserByUsername")
	}

	mmGetUserByUsername.mock.inspectFuncGetUserByUsername = f

	return mmGetUserByUsername
}

// Return sets up results that will be returned by Repository.GetUserByUsername
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) Return(up1 *models.User, err error) *RepositoryMock {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("RepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &RepositoryMockGetUserByUsernameExpectation{mock: mmGetUserByUsername.mock}
	}
	mmGetUserByUsername.defaultExpectation.results = &RepositoryMockGetUserByUsernameResults{up1, err}
	mmGetUserByUsername.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername.mock
}

// Set uses given function f to mock the Repository.GetUserByUsername method
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) Set(f func(ctx context.Context, username string) (up1 *models.User, err error)) *RepositoryMock {
	if mmGetUserByUsername.defaultExpectation != nil {
		mmGetUserByUsername.mock.t.Fatalf("Default expectation is already set for the Repository.GetUserByUsername method")
	}

	if len(mmGetUserByUsername.expectations) > 0 {
		mmGetUserByUsername.mock.t.Fatalf("Some expectations are already set for the Repository.GetUserByUsername method")
	}

	mmGetUserByUsername.mock.funcGetUserByUsername = f
	mmGetUserByUsername.mock.funcGetUserByUsernameOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername.mock
}

// When sets expectation for the Repository.GetUserByUsername which will trigger the result defined by the following
// Then helper
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) When(ctx context.Context, username string) *RepositoryMockGetUserByUsernameExpectation {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("RepositoryMock.GetUserByUsername mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserByUsernameExpectation{
		mock:               mmGetUserByUsername.mock,
		params:             &RepositoryMockGetUserByUsernameParams{ctx, username},
		expectationOrigins: RepositoryMockGetUserByUsernameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByUsername.expectations = append(mmGetUserByUsername.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUserByUsername return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserByUsernameExpectation) Then(up1 *models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserByUsernameResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.GetUserByUsername should be invoked
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) Times(n uint64) *mRepositoryMockGetUserByUsername {
	if n == 0 {
		mmGetUserByUsername.mock.t.Fatalf("Times of RepositoryMock.GetUserByUsername mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByUsername.expectedInvocations, n)
	mmGetUserByUsername.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername
}

func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) invocationsDone() bool {
	if len(mmGetUserByUsername.expectations) == 0 && mmGetUserByUsername.defaultExpectation == nil && mmGetUserByUsername.mock.funcGetUserByUsername == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByUsername.mock.afterGetUserByUsernameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByUsername.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByUsername implements mm_user.Repository
func (mmGetUserByUsername *RepositoryMock) GetUserByUsername(ctx context.Context, username string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByUsername.beforeGetUserByUsernameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByUsername.afterGetUserByUsernameCounter, 1)

	mmGetUserByUsername.t.Helper()

	if mmGetUserByUsername.inspectFuncGetUserByUsername != nil {
		mmGetUserByUsername.inspectFuncGetUserByUsername(ctx, username)
	}

	mm_params := RepositoryMockGetUserByUsernameParams{ctx, username}

	// Record call args
	mmGetUserByUsername.GetUserByUsernameMock.mutex.Lock()
	mmGetUserByUsername.GetUserByUsernameMock.callArgs = append(mmGetUserByUsername.GetUserByUsernameMock.callArgs, &mm_params)
	mmGetUserByUsername.GetUserByUsernameMock.mutex.Unlock()

	for _, e := range mmGetUserByUsername.GetUserByUsernameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetUserByUsernameParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByUsername.t.Errorf("RepositoryMock.GetUserByUsername got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserByUsername.t.Errorf("RepositoryMock.GetUserByUsername got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByUsername.t.Errorf("RepositoryMock.GetUserByUsername got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByUsername.t.Fatal("No results are set for the RepositoryMock.GetUserByUsername")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByUsername.funcGetUserByUsername != nil {
		return mmGetUserByUsername.funcGetUserByUsername(ctx, username)
	}
	mmGetUserByUsername.t.Fatalf("Unexpected call to RepositoryMock.GetUserByUsername. %v %v", ctx, username)
	return
}

// GetUserByUsernameAfterCounter returns a count of finished RepositoryMock.GetUserByUsername invocations
func (mmGetUserByUsername *RepositoryMock) GetUserByUsernameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByUsername.afterGetUserByUsernameCounter)
}

// GetUserByUsernameBeforeCounter returns a count of RepositoryMock.GetUserByUsername invocations
func (mmGetUserByUsername *RepositoryMock) GetUserByUsernameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByUsername.beforeGetUserByUsernameCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUserByUsername.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByUsername *mRepositoryMockGetUserByUsername) Calls() []*RepositoryMockGetUserByUsernameParams {
	mmGetUserByUsername.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserByUsernameParams, len(mmGetUserByUsername.callArgs))
	copy(argCopy, mmGetUserByUsername.callArgs)

	mmGetUserByUsername.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByUsernameDone returns true if the count of the GetUserByUsername invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserByUsernameDone() bool {
	if m.GetUserByUsernameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByUsernameMock.invocationsDone()
}

// MinimockGetUserByUsernameInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserByUsernameInspect() {
	for _, e := range m.GetUserByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByUsername at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByUsernameCounter := mm_atomic.LoadUint64(&m.afterGetUserByUsernameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByUsernameMock.defaultExpectation != nil && afterGetUserByUsernameCounter < 1 {
		if m.GetUserByUsernameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByUsername at\n%s", m.GetUserByUsernameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByUsername at\n%s with params: %#v", m.GetUserByUsernameMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByUsernameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByUsername != nil && afterGetUserByUsernameCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetUserByUsername at\n%s", m.funcGetUserByUsernameOrigin)
	}

	if !m.GetUserByUsernameMock.invocationsDone() && afterGetUserByUsernameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetUserByUsername at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByUsernameMock.expectedInvocations), m.GetUserByUsernameMock.expectedInvocationsOrigin, afterGetUserByUsernameCounter)
	}
}

type mRepositoryMockUpdateUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateUserExpectation
	expectations       []*RepositoryMockUpdateUserExpectation

	callArgs []*RepositoryMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateUserExpectation specifies expectation struct of the Repository.UpdateUser
type RepositoryMockUpdateUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateUserParams
	paramPtrs          *RepositoryMockUpdateUserParamPtrs
	expectationOrigins RepositoryMockUpdateUserExpectationOrigins
	results            *RepositoryMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateUserParams contains parameters of the Repository.UpdateUser
type RepositoryMockUpdateUserParams struct {
	ctx         context.Context
	id          int64
	oldPassword string
	newPassword string
}

// RepositoryMockUpdateUserParamPtrs contains pointers to parameters of the Repository.UpdateUser
type RepositoryMockUpdateUserParamPtrs struct {
	ctx         *context.Context
	id          *int64
	oldPassword *string
	newPassword *string
}

// RepositoryMockUpdateUserResults contains results of the Repository.UpdateUser
type RepositoryMockUpdateUserResults struct {
	err error
}

// RepositoryMockUpdateUserOrigins contains origins of expectations of the Repository.UpdateUser
type RepositoryMockUpdateUserExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originOldPassword string
	originNewPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mRepositoryMockUpdateUser) Optional() *mRepositoryMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Expect(ctx context.Context, id int64, oldPassword string, newPassword string) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &RepositoryMockUpdateUserParams{ctx, id, oldPassword, newPassword}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectIdParam2 sets up expected param id for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) ExpectIdParam2(id int64) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.id = &id
	mmUpdateUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectOldPasswordParam3 sets up expected param oldPassword for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) ExpectOldPasswordParam3(oldPassword string) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.oldPassword = &oldPassword
	mmUpdateUser.defaultExpectation.expectationOrigins.originOldPassword = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectNewPasswordParam4 sets up expected param newPassword for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) ExpectNewPasswordParam4(newPassword string) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.newPassword = &newPassword
	mmUpdateUser.defaultExpectation.expectationOrigins.originNewPassword = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, id int64, oldPassword string, newPassword string)) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Return(err error) *RepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &RepositoryMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the Repository.UpdateUser method
func (mmUpdateUser *mRepositoryMockUpdateUser) Set(f func(ctx context.Context, id int64, oldPassword string, newPassword string) (err error)) *RepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the Repository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mRepositoryMockUpdateUser) When(ctx context.Context, id int64, oldPassword string, newPassword string) *RepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &RepositoryMockUpdateUserParams{ctx, id, oldPassword, newPassword},
		expectationOrigins: RepositoryMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateUser should be invoked
func (mmUpdateUser *mRepositoryMockUpdateUser) Times(n uint64) *mRepositoryMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of RepositoryMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mRepositoryMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_user.Repository
func (mmUpdateUser *RepositoryMock) UpdateUser(ctx context.Context, id int64, oldPassword string, newPassword string) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, id, oldPassword, newPassword)
	}

	mm_params := RepositoryMockUpdateUserParams{ctx, id, oldPassword, newPassword}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateUserParams{ctx, id, oldPassword, newPassword}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.oldPassword != nil && !minimock.Equal(*mm_want_ptrs.oldPassword, mm_got.oldPassword) {
				mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameter oldPassword, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originOldPassword, *mm_want_ptrs.oldPassword, mm_got.oldPassword, minimock.Diff(*mm_want_ptrs.oldPassword, mm_got.oldPassword))
			}

			if mm_want_ptrs.newPassword != nil && !minimock.Equal(*mm_want_ptrs.newPassword, mm_got.newPassword) {
				mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameter newPassword, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originNewPassword, *mm_want_ptrs.newPassword, mm_got.newPassword, minimock.Diff(*mm_want_ptrs.newPassword, mm_got.newPassword))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the RepositoryMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, id, oldPassword, newPassword)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to RepositoryMock.UpdateUser. %v %v %v %v", ctx, id, oldPassword, newPassword)
	return
}

// UpdateUserAfterCounter returns a count of finished RepositoryMock.UpdateUser invocations
func (mmUpdateUser *RepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of RepositoryMock.UpdateUser invocations
func (mmUpdateUser *RepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mRepositoryMockUpdateUser) Calls() []*RepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserByIDInspect()

			m.MinimockGetUserByUsernameInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockGetUserByUsernameDone() &&
		m.MinimockUpdateUserDone()
}
