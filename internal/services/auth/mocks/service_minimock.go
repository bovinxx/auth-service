// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/bovinxx/auth-service/internal/services/auth.Service -o service_minimock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	desc "github.com/bovinxx/auth-service/pkg/auth_v1"
	"github.com/gojuno/minimock/v3"
)

// ServiceMock implements mm_service.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAccessToken          func(ctx context.Context, req *desc.GetAccessTokenRequest) (gp1 *desc.GetAccessTokenResponse, err error)
	funcGetAccessTokenOrigin    string
	inspectFuncGetAccessToken   func(ctx context.Context, req *desc.GetAccessTokenRequest)
	afterGetAccessTokenCounter  uint64
	beforeGetAccessTokenCounter uint64
	GetAccessTokenMock          mServiceMockGetAccessToken

	funcGetRefreshToken          func(ctx context.Context, req *desc.GetRefreshTokenRequest) (gp1 *desc.GetRefreshTokenResponse, err error)
	funcGetRefreshTokenOrigin    string
	inspectFuncGetRefreshToken   func(ctx context.Context, req *desc.GetRefreshTokenRequest)
	afterGetRefreshTokenCounter  uint64
	beforeGetRefreshTokenCounter uint64
	GetRefreshTokenMock          mServiceMockGetRefreshToken

	funcLogin          func(ctx context.Context, req *desc.LoginRequest) (lp1 *desc.LoginResponse, err error)
	funcLoginOrigin    string
	inspectFuncLogin   func(ctx context.Context, req *desc.LoginRequest)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mServiceMockLogin
}

// NewServiceMock returns a mock for mm_service.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAccessTokenMock = mServiceMockGetAccessToken{mock: m}
	m.GetAccessTokenMock.callArgs = []*ServiceMockGetAccessTokenParams{}

	m.GetRefreshTokenMock = mServiceMockGetRefreshToken{mock: m}
	m.GetRefreshTokenMock.callArgs = []*ServiceMockGetRefreshTokenParams{}

	m.LoginMock = mServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*ServiceMockLoginParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockGetAccessToken struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetAccessTokenExpectation
	expectations       []*ServiceMockGetAccessTokenExpectation

	callArgs []*ServiceMockGetAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetAccessTokenExpectation specifies expectation struct of the Service.GetAccessToken
type ServiceMockGetAccessTokenExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetAccessTokenParams
	paramPtrs          *ServiceMockGetAccessTokenParamPtrs
	expectationOrigins ServiceMockGetAccessTokenExpectationOrigins
	results            *ServiceMockGetAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetAccessTokenParams contains parameters of the Service.GetAccessToken
type ServiceMockGetAccessTokenParams struct {
	ctx context.Context
	req *desc.GetAccessTokenRequest
}

// ServiceMockGetAccessTokenParamPtrs contains pointers to parameters of the Service.GetAccessToken
type ServiceMockGetAccessTokenParamPtrs struct {
	ctx *context.Context
	req **desc.GetAccessTokenRequest
}

// ServiceMockGetAccessTokenResults contains results of the Service.GetAccessToken
type ServiceMockGetAccessTokenResults struct {
	gp1 *desc.GetAccessTokenResponse
	err error
}

// ServiceMockGetAccessTokenOrigins contains origins of expectations of the Service.GetAccessToken
type ServiceMockGetAccessTokenExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccessToken *mServiceMockGetAccessToken) Optional() *mServiceMockGetAccessToken {
	mmGetAccessToken.optional = true
	return mmGetAccessToken
}

// Expect sets up expected params for Service.GetAccessToken
func (mmGetAccessToken *mServiceMockGetAccessToken) Expect(ctx context.Context, req *desc.GetAccessTokenRequest) *mServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("ServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &ServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs != nil {
		mmGetAccessToken.mock.t.Fatalf("ServiceMock.GetAccessToken mock is already set by ExpectParams functions")
	}

	mmGetAccessToken.defaultExpectation.params = &ServiceMockGetAccessTokenParams{ctx, req}
	mmGetAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAccessToken.expectations {
		if minimock.Equal(e.params, mmGetAccessToken.defaultExpectation.params) {
			mmGetAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccessToken.defaultExpectation.params)
		}
	}

	return mmGetAccessToken
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetAccessToken
func (mmGetAccessToken *mServiceMockGetAccessToken) ExpectCtxParam1(ctx context.Context) *mServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("ServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &ServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("ServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &ServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAccessToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAccessToken
}

// ExpectReqParam2 sets up expected param req for Service.GetAccessToken
func (mmGetAccessToken *mServiceMockGetAccessToken) ExpectReqParam2(req *desc.GetAccessTokenRequest) *mServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("ServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &ServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("ServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &ServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.req = &req
	mmGetAccessToken.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmGetAccessToken
}

// Inspect accepts an inspector function that has same arguments as the Service.GetAccessToken
func (mmGetAccessToken *mServiceMockGetAccessToken) Inspect(f func(ctx context.Context, req *desc.GetAccessTokenRequest)) *mServiceMockGetAccessToken {
	if mmGetAccessToken.mock.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetAccessToken")
	}

	mmGetAccessToken.mock.inspectFuncGetAccessToken = f

	return mmGetAccessToken
}

// Return sets up results that will be returned by Service.GetAccessToken
func (mmGetAccessToken *mServiceMockGetAccessToken) Return(gp1 *desc.GetAccessTokenResponse, err error) *ServiceMock {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("ServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &ServiceMockGetAccessTokenExpectation{mock: mmGetAccessToken.mock}
	}
	mmGetAccessToken.defaultExpectation.results = &ServiceMockGetAccessTokenResults{gp1, err}
	mmGetAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAccessToken.mock
}

// Set uses given function f to mock the Service.GetAccessToken method
func (mmGetAccessToken *mServiceMockGetAccessToken) Set(f func(ctx context.Context, req *desc.GetAccessTokenRequest) (gp1 *desc.GetAccessTokenResponse, err error)) *ServiceMock {
	if mmGetAccessToken.defaultExpectation != nil {
		mmGetAccessToken.mock.t.Fatalf("Default expectation is already set for the Service.GetAccessToken method")
	}

	if len(mmGetAccessToken.expectations) > 0 {
		mmGetAccessToken.mock.t.Fatalf("Some expectations are already set for the Service.GetAccessToken method")
	}

	mmGetAccessToken.mock.funcGetAccessToken = f
	mmGetAccessToken.mock.funcGetAccessTokenOrigin = minimock.CallerInfo(1)
	return mmGetAccessToken.mock
}

// When sets expectation for the Service.GetAccessToken which will trigger the result defined by the following
// Then helper
func (mmGetAccessToken *mServiceMockGetAccessToken) When(ctx context.Context, req *desc.GetAccessTokenRequest) *ServiceMockGetAccessTokenExpectation {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("ServiceMock.GetAccessToken mock is already set by Set")
	}

	expectation := &ServiceMockGetAccessTokenExpectation{
		mock:               mmGetAccessToken.mock,
		params:             &ServiceMockGetAccessTokenParams{ctx, req},
		expectationOrigins: ServiceMockGetAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAccessToken.expectations = append(mmGetAccessToken.expectations, expectation)
	return expectation
}

// Then sets up Service.GetAccessToken return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetAccessTokenExpectation) Then(gp1 *desc.GetAccessTokenResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetAccessTokenResults{gp1, err}
	return e.mock
}

// Times sets number of times Service.GetAccessToken should be invoked
func (mmGetAccessToken *mServiceMockGetAccessToken) Times(n uint64) *mServiceMockGetAccessToken {
	if n == 0 {
		mmGetAccessToken.mock.t.Fatalf("Times of ServiceMock.GetAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccessToken.expectedInvocations, n)
	mmGetAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAccessToken
}

func (mmGetAccessToken *mServiceMockGetAccessToken) invocationsDone() bool {
	if len(mmGetAccessToken.expectations) == 0 && mmGetAccessToken.defaultExpectation == nil && mmGetAccessToken.mock.funcGetAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.mock.afterGetAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccessToken implements mm_service.Service
func (mmGetAccessToken *ServiceMock) GetAccessToken(ctx context.Context, req *desc.GetAccessTokenRequest) (gp1 *desc.GetAccessTokenResponse, err error) {
	mm_atomic.AddUint64(&mmGetAccessToken.beforeGetAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccessToken.afterGetAccessTokenCounter, 1)

	mmGetAccessToken.t.Helper()

	if mmGetAccessToken.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.inspectFuncGetAccessToken(ctx, req)
	}

	mm_params := ServiceMockGetAccessTokenParams{ctx, req}

	// Record call args
	mmGetAccessToken.GetAccessTokenMock.mutex.Lock()
	mmGetAccessToken.GetAccessTokenMock.callArgs = append(mmGetAccessToken.GetAccessTokenMock.callArgs, &mm_params)
	mmGetAccessToken.GetAccessTokenMock.mutex.Unlock()

	for _, e := range mmGetAccessToken.GetAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetAccessToken.GetAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccessToken.GetAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetAccessTokenParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccessToken.t.Errorf("ServiceMock.GetAccessToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccessToken.GetAccessTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmGetAccessToken.t.Errorf("ServiceMock.GetAccessToken got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccessToken.GetAccessTokenMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccessToken.t.Errorf("ServiceMock.GetAccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAccessToken.GetAccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccessToken.t.Fatal("No results are set for the ServiceMock.GetAccessToken")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetAccessToken.funcGetAccessToken != nil {
		return mmGetAccessToken.funcGetAccessToken(ctx, req)
	}
	mmGetAccessToken.t.Fatalf("Unexpected call to ServiceMock.GetAccessToken. %v %v", ctx, req)
	return
}

// GetAccessTokenAfterCounter returns a count of finished ServiceMock.GetAccessToken invocations
func (mmGetAccessToken *ServiceMock) GetAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.afterGetAccessTokenCounter)
}

// GetAccessTokenBeforeCounter returns a count of ServiceMock.GetAccessToken invocations
func (mmGetAccessToken *ServiceMock) GetAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.beforeGetAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccessToken *mServiceMockGetAccessToken) Calls() []*ServiceMockGetAccessTokenParams {
	mmGetAccessToken.mutex.RLock()

	argCopy := make([]*ServiceMockGetAccessTokenParams, len(mmGetAccessToken.callArgs))
	copy(argCopy, mmGetAccessToken.callArgs)

	mmGetAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessTokenDone returns true if the count of the GetAccessToken invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetAccessTokenDone() bool {
	if m.GetAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccessTokenMock.invocationsDone()
}

// MinimockGetAccessTokenInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetAccessTokenInspect() {
	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetAccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAccessTokenCounter := mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessTokenMock.defaultExpectation != nil && afterGetAccessTokenCounter < 1 {
		if m.GetAccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetAccessToken at\n%s", m.GetAccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetAccessToken at\n%s with params: %#v", m.GetAccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.GetAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccessToken != nil && afterGetAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetAccessToken at\n%s", m.funcGetAccessTokenOrigin)
	}

	if !m.GetAccessTokenMock.invocationsDone() && afterGetAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetAccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccessTokenMock.expectedInvocations), m.GetAccessTokenMock.expectedInvocationsOrigin, afterGetAccessTokenCounter)
	}
}

type mServiceMockGetRefreshToken struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetRefreshTokenExpectation
	expectations       []*ServiceMockGetRefreshTokenExpectation

	callArgs []*ServiceMockGetRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetRefreshTokenExpectation specifies expectation struct of the Service.GetRefreshToken
type ServiceMockGetRefreshTokenExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetRefreshTokenParams
	paramPtrs          *ServiceMockGetRefreshTokenParamPtrs
	expectationOrigins ServiceMockGetRefreshTokenExpectationOrigins
	results            *ServiceMockGetRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetRefreshTokenParams contains parameters of the Service.GetRefreshToken
type ServiceMockGetRefreshTokenParams struct {
	ctx context.Context
	req *desc.GetRefreshTokenRequest
}

// ServiceMockGetRefreshTokenParamPtrs contains pointers to parameters of the Service.GetRefreshToken
type ServiceMockGetRefreshTokenParamPtrs struct {
	ctx *context.Context
	req **desc.GetRefreshTokenRequest
}

// ServiceMockGetRefreshTokenResults contains results of the Service.GetRefreshToken
type ServiceMockGetRefreshTokenResults struct {
	gp1 *desc.GetRefreshTokenResponse
	err error
}

// ServiceMockGetRefreshTokenOrigins contains origins of expectations of the Service.GetRefreshToken
type ServiceMockGetRefreshTokenExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefreshToken *mServiceMockGetRefreshToken) Optional() *mServiceMockGetRefreshToken {
	mmGetRefreshToken.optional = true
	return mmGetRefreshToken
}

// Expect sets up expected params for Service.GetRefreshToken
func (mmGetRefreshToken *mServiceMockGetRefreshToken) Expect(ctx context.Context, req *desc.GetRefreshTokenRequest) *mServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("ServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &ServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs != nil {
		mmGetRefreshToken.mock.t.Fatalf("ServiceMock.GetRefreshToken mock is already set by ExpectParams functions")
	}

	mmGetRefreshToken.defaultExpectation.params = &ServiceMockGetRefreshTokenParams{ctx, req}
	mmGetRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRefreshToken.expectations {
		if minimock.Equal(e.params, mmGetRefreshToken.defaultExpectation.params) {
			mmGetRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefreshToken.defaultExpectation.params)
		}
	}

	return mmGetRefreshToken
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetRefreshToken
func (mmGetRefreshToken *mServiceMockGetRefreshToken) ExpectCtxParam1(ctx context.Context) *mServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("ServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &ServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("ServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &ServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRefreshToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRefreshToken
}

// ExpectReqParam2 sets up expected param req for Service.GetRefreshToken
func (mmGetRefreshToken *mServiceMockGetRefreshToken) ExpectReqParam2(req *desc.GetRefreshTokenRequest) *mServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("ServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &ServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("ServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &ServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.req = &req
	mmGetRefreshToken.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmGetRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the Service.GetRefreshToken
func (mmGetRefreshToken *mServiceMockGetRefreshToken) Inspect(f func(ctx context.Context, req *desc.GetRefreshTokenRequest)) *mServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetRefreshToken")
	}

	mmGetRefreshToken.mock.inspectFuncGetRefreshToken = f

	return mmGetRefreshToken
}

// Return sets up results that will be returned by Service.GetRefreshToken
func (mmGetRefreshToken *mServiceMockGetRefreshToken) Return(gp1 *desc.GetRefreshTokenResponse, err error) *ServiceMock {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("ServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &ServiceMockGetRefreshTokenExpectation{mock: mmGetRefreshToken.mock}
	}
	mmGetRefreshToken.defaultExpectation.results = &ServiceMockGetRefreshTokenResults{gp1, err}
	mmGetRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRefreshToken.mock
}

// Set uses given function f to mock the Service.GetRefreshToken method
func (mmGetRefreshToken *mServiceMockGetRefreshToken) Set(f func(ctx context.Context, req *desc.GetRefreshTokenRequest) (gp1 *desc.GetRefreshTokenResponse, err error)) *ServiceMock {
	if mmGetRefreshToken.defaultExpectation != nil {
		mmGetRefreshToken.mock.t.Fatalf("Default expectation is already set for the Service.GetRefreshToken method")
	}

	if len(mmGetRefreshToken.expectations) > 0 {
		mmGetRefreshToken.mock.t.Fatalf("Some expectations are already set for the Service.GetRefreshToken method")
	}

	mmGetRefreshToken.mock.funcGetRefreshToken = f
	mmGetRefreshToken.mock.funcGetRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmGetRefreshToken.mock
}

// When sets expectation for the Service.GetRefreshToken which will trigger the result defined by the following
// Then helper
func (mmGetRefreshToken *mServiceMockGetRefreshToken) When(ctx context.Context, req *desc.GetRefreshTokenRequest) *ServiceMockGetRefreshTokenExpectation {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("ServiceMock.GetRefreshToken mock is already set by Set")
	}

	expectation := &ServiceMockGetRefreshTokenExpectation{
		mock:               mmGetRefreshToken.mock,
		params:             &ServiceMockGetRefreshTokenParams{ctx, req},
		expectationOrigins: ServiceMockGetRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRefreshToken.expectations = append(mmGetRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up Service.GetRefreshToken return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetRefreshTokenExpectation) Then(gp1 *desc.GetRefreshTokenResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetRefreshTokenResults{gp1, err}
	return e.mock
}

// Times sets number of times Service.GetRefreshToken should be invoked
func (mmGetRefreshToken *mServiceMockGetRefreshToken) Times(n uint64) *mServiceMockGetRefreshToken {
	if n == 0 {
		mmGetRefreshToken.mock.t.Fatalf("Times of ServiceMock.GetRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefreshToken.expectedInvocations, n)
	mmGetRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRefreshToken
}

func (mmGetRefreshToken *mServiceMockGetRefreshToken) invocationsDone() bool {
	if len(mmGetRefreshToken.expectations) == 0 && mmGetRefreshToken.defaultExpectation == nil && mmGetRefreshToken.mock.funcGetRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.mock.afterGetRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefreshToken implements mm_service.Service
func (mmGetRefreshToken *ServiceMock) GetRefreshToken(ctx context.Context, req *desc.GetRefreshTokenRequest) (gp1 *desc.GetRefreshTokenResponse, err error) {
	mm_atomic.AddUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter, 1)

	mmGetRefreshToken.t.Helper()

	if mmGetRefreshToken.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.inspectFuncGetRefreshToken(ctx, req)
	}

	mm_params := ServiceMockGetRefreshTokenParams{ctx, req}

	// Record call args
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Lock()
	mmGetRefreshToken.GetRefreshTokenMock.callArgs = append(mmGetRefreshToken.GetRefreshTokenMock.callArgs, &mm_params)
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Unlock()

	for _, e := range mmGetRefreshToken.GetRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetRefreshTokenParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRefreshToken.t.Errorf("ServiceMock.GetRefreshToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmGetRefreshToken.t.Errorf("ServiceMock.GetRefreshToken got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefreshToken.t.Errorf("ServiceMock.GetRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefreshToken.t.Fatal("No results are set for the ServiceMock.GetRefreshToken")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetRefreshToken.funcGetRefreshToken != nil {
		return mmGetRefreshToken.funcGetRefreshToken(ctx, req)
	}
	mmGetRefreshToken.t.Fatalf("Unexpected call to ServiceMock.GetRefreshToken. %v %v", ctx, req)
	return
}

// GetRefreshTokenAfterCounter returns a count of finished ServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *ServiceMock) GetRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter)
}

// GetRefreshTokenBeforeCounter returns a count of ServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *ServiceMock) GetRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefreshToken *mServiceMockGetRefreshToken) Calls() []*ServiceMockGetRefreshTokenParams {
	mmGetRefreshToken.mutex.RLock()

	argCopy := make([]*ServiceMockGetRefreshTokenParams, len(mmGetRefreshToken.callArgs))
	copy(argCopy, mmGetRefreshToken.callArgs)

	mmGetRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefreshTokenDone returns true if the count of the GetRefreshToken invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetRefreshTokenDone() bool {
	if m.GetRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefreshTokenMock.invocationsDone()
}

// MinimockGetRefreshTokenInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetRefreshTokenInspect() {
	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenMock.defaultExpectation != nil && afterGetRefreshTokenCounter < 1 {
		if m.GetRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetRefreshToken at\n%s", m.GetRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetRefreshToken at\n%s with params: %#v", m.GetRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.GetRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshToken != nil && afterGetRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetRefreshToken at\n%s", m.funcGetRefreshTokenOrigin)
	}

	if !m.GetRefreshTokenMock.invocationsDone() && afterGetRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefreshTokenMock.expectedInvocations), m.GetRefreshTokenMock.expectedInvocationsOrigin, afterGetRefreshTokenCounter)
	}
}

type mServiceMockLogin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockLoginExpectation
	expectations       []*ServiceMockLoginExpectation

	callArgs []*ServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockLoginExpectation specifies expectation struct of the Service.Login
type ServiceMockLoginExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockLoginParams
	paramPtrs          *ServiceMockLoginParamPtrs
	expectationOrigins ServiceMockLoginExpectationOrigins
	results            *ServiceMockLoginResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockLoginParams contains parameters of the Service.Login
type ServiceMockLoginParams struct {
	ctx context.Context
	req *desc.LoginRequest
}

// ServiceMockLoginParamPtrs contains pointers to parameters of the Service.Login
type ServiceMockLoginParamPtrs struct {
	ctx *context.Context
	req **desc.LoginRequest
}

// ServiceMockLoginResults contains results of the Service.Login
type ServiceMockLoginResults struct {
	lp1 *desc.LoginResponse
	err error
}

// ServiceMockLoginOrigins contains origins of expectations of the Service.Login
type ServiceMockLoginExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mServiceMockLogin) Optional() *mServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for Service.Login
func (mmLogin *mServiceMockLogin) Expect(ctx context.Context, req *desc.LoginRequest) *mServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("ServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &ServiceMockLoginParams{ctx, req}
	mmLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for Service.Login
func (mmLogin *mServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("ServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &ServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectReqParam2 sets up expected param req for Service.Login
func (mmLogin *mServiceMockLogin) ExpectReqParam2(req *desc.LoginRequest) *mServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("ServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &ServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.req = &req
	mmLogin.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the Service.Login
func (mmLogin *mServiceMockLogin) Inspect(f func(ctx context.Context, req *desc.LoginRequest)) *mServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for ServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by Service.Login
func (mmLogin *mServiceMockLogin) Return(lp1 *desc.LoginResponse, err error) *ServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &ServiceMockLoginResults{lp1, err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the Service.Login method
func (mmLogin *mServiceMockLogin) Set(f func(ctx context.Context, req *desc.LoginRequest) (lp1 *desc.LoginResponse, err error)) *ServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the Service.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the Service.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// When sets expectation for the Service.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mServiceMockLogin) When(ctx context.Context, req *desc.LoginRequest) *ServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ServiceMock.Login mock is already set by Set")
	}

	expectation := &ServiceMockLoginExpectation{
		mock:               mmLogin.mock,
		params:             &ServiceMockLoginParams{ctx, req},
		expectationOrigins: ServiceMockLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up Service.Login return parameters for the expectation previously defined by the When method
func (e *ServiceMockLoginExpectation) Then(lp1 *desc.LoginResponse, err error) *ServiceMock {
	e.results = &ServiceMockLoginResults{lp1, err}
	return e.mock
}

// Times sets number of times Service.Login should be invoked
func (mmLogin *mServiceMockLogin) Times(n uint64) *mServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of ServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements mm_service.Service
func (mmLogin *ServiceMock) Login(ctx context.Context, req *desc.LoginRequest) (lp1 *desc.LoginResponse, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, req)
	}

	mm_params := ServiceMockLoginParams{ctx, req}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockLoginParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("ServiceMock.Login got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmLogin.t.Errorf("ServiceMock.Login got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("ServiceMock.Login got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogin.LoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the ServiceMock.Login")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, req)
	}
	mmLogin.t.Fatalf("Unexpected call to ServiceMock.Login. %v %v", ctx, req)
	return
}

// LoginAfterCounter returns a count of finished ServiceMock.Login invocations
func (mmLogin *ServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of ServiceMock.Login invocations
func (mmLogin *ServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mServiceMockLogin) Calls() []*ServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*ServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *ServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Login at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Login at\n%s with params: %#v", m.LoginMock.defaultExpectation.expectationOrigins.origin, *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAccessTokenInspect()

			m.MinimockGetRefreshTokenInspect()

			m.MinimockLoginInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAccessTokenDone() &&
		m.MinimockGetRefreshTokenDone() &&
		m.MinimockLoginDone()
}
